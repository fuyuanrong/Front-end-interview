<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>闭包</title>

	<style type="text/css">
		
	</style>
</head>
<body>
	<div class="container">
		
		<div id="a">

		</div>
		<div id="b">

		</div>
		<h5>一、闭包概念</h5>
		<p> <strong>官方:</strong> 闭包是指有权访问另一个函数作用域中的变量的函数</p>
		<p>函数套函数,并把内部函数return,内部函数可以访问外部函数的变量,一级级向上找。</p>
		<p>能够读取其他函数内部变量的函数,定义在一个函数内部的函数,持有外部环境变量的函数。</p>
		<p>闭包就是能够读取其他函数内部变量的函数。</p>
		<p>能够读取其他函数内部变量的函数</p>
		<p>闭包可以在其他函数的执行上下文中，访问到函数的内部变量。</p>


		<h5>二闭包的特性</h5>

		<p> 1、函数嵌套函数。</p>

		<p>2、函数内部可以引用函数外部的参数和变量。</p> 

		<p>3、参数和变量不会被垃圾回收机制回收。</p> 



		<h5>三、闭包的作用</h5> 

		<p>1、读取函数内部的变量。</p> 

		<p>2、让变量的值始终保持在内存中,延长变量的生命周期</p> 



		<h5>四、闭包的优缺点</h5> 

		<p>优点：</p>

		<p>1、保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突。</p> 

		<p>2、在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）。</p> 

		<p>3、匿名自执行函数可以减少内存消耗。</p> 



		<p>缺点：</p>

		<p>1、其中一点上面已经有体现了，就是被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；</p> 

		<p>2、其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。</p> 

	</div>
	<script>
		var a = 1;
		var b = 3;
		function fun1(){
			var a = 2;
			console.log('a==>',a);
			console.log('b==>',b);
			function fun1_1(){
				console.log('a_1==>',a);

			}
			fun1_1();
		}
		function fun2(){
			console.log('fun2 a==>',a);
		}
		fun1();
		fun2();
		// 闭包:一个函数对周围状态的引用捆绑在一起,内层函数中访问到其外层函数的作用域
		//简单理解:闭包 =  内层函数 + 引用的外层函数变量
		//  如上图   70行到 76行
		// 通常会再使用一个函数包裹住 闭包结构,以起到对变量的保护
		// 外界函数如果想要使用到闭包的变量,则需要return
		//闭包不一定由return 不一定会造成内存泄漏


		//闭包应用   => 处理私有数据
		let makeCounter = function (){
			let privateCounter = 0;
			function changeBy(val) {
				privateCounter += val;
			}
			return {
				increment:function(){
					changeBy(1);
				},
				decrement:function(){
					changeBy(-1);
				},
				value:function(){
					return privateCounter;
				}
			}
		}
	</script>
</body>
</html>